{"ast":null,"code":"(function () {\n  var enterModule = (typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal : require('react-hot-loader')).enterModule;\n  enterModule && enterModule(module);\n})();\n\nvar Class = require('../../core/class');\n\nvar Transform = require('../../core/transform');\n\nvar Color = require('../../core/color');\n\nvar Node = require('./node');\n\nvar DOM = require('./dom');\n\nvar precision = 100;\nvar defaultBox = {\n  left: 0,\n  top: 0,\n  width: 500,\n  height: 500\n};\nmodule.exports = Class(Node, {\n  element_initialize: Node.prototype.initialize,\n  initialize: function initialize(tag) {\n    this.element_initialize(tag);\n    var element = this.element;\n    var skew = this.skewElement = DOM.createElement('skew');\n    skew.on = true;\n    element.appendChild(skew);\n    var fill = this.fillElement = DOM.createElement('fill');\n    fill.on = false;\n    element.appendChild(fill);\n    var stroke = this.strokeElement = DOM.createElement('stroke');\n    stroke.on = false;\n    element.appendChild(stroke);\n  },\n\n  /* transform */\n  _transform: function _transform() {\n    var container = this.parentNode; // Active Transformation Matrix\n\n    var m = container ? new Transform(container._activeTransform).transform(this) : this; // Box in shape user space\n\n    var box = this._boxCoords || this._size || defaultBox;\n    var originX = box.left || 0,\n        originY = box.top || 0,\n        width = box.width || 1,\n        height = box.height || 1; // Flipped\n\n    var flip = m.yx / m.xx > m.yy / m.xy;\n    if (m.xx < 0 ? m.xy >= 0 : m.xy < 0) flip = !flip;\n    flip = flip ? -1 : 1;\n    m = new Transform().scale(flip, 1).transform(m); // Rotation is approximated based on the transform\n\n    var rotation = Math.atan2(-m.xy, m.yy) * 180 / Math.PI; // Reverse the rotation, leaving the final transform in box space\n\n    var rad = rotation * Math.PI / 180,\n        sin = Math.sin(rad),\n        cos = Math.cos(rad);\n    var transform = new Transform(m.xx * cos - m.xy * sin, (m.yx * cos - m.yy * sin) * flip, (m.xy * cos + m.xx * sin) * flip, m.yy * cos + m.yx * sin);\n    var rotationTransform = new Transform().rotate(rotation, 0, 0);\n    var shapeToBox = new Transform().rotate(-rotation, 0, 0).transform(m).moveTo(0, 0); // Scale box after reversing rotation\n\n    width *= Math.abs(shapeToBox.xx);\n    height *= Math.abs(shapeToBox.yy); // Place box\n\n    var left = m.x,\n        top = m.y; // Compensate for offset by center origin rotation\n\n    var vx = -width / 2,\n        vy = -height / 2;\n    var point = rotationTransform.point(vx, vy);\n    left -= point.x - vx;\n    top -= point.y - vy; // Adjust box position based on offset\n\n    var rsm = new Transform(m).moveTo(0, 0);\n    point = rsm.point(originX, originY);\n    left += point.x;\n    top += point.y;\n    if (flip < 0) left = -left - width; // Place transformation origin\n\n    var point0 = rsm.point(-originX, -originY);\n    var point1 = rotationTransform.point(width, height);\n    var point2 = rotationTransform.point(width, 0);\n    var point3 = rotationTransform.point(0, height);\n    var minX = Math.min(0, point1.x, point2.x, point3.x),\n        maxX = Math.max(0, point1.x, point2.x, point3.x),\n        minY = Math.min(0, point1.y, point2.y, point3.y),\n        maxY = Math.max(0, point1.y, point2.y, point3.y);\n    var transformOriginX = (point0.x - point1.x / 2) / (maxX - minX) * flip,\n        transformOriginY = (point0.y - point1.y / 2) / (maxY - minY); // Adjust the origin\n\n    point = shapeToBox.point(originX, originY);\n    originX = point.x;\n    originY = point.y; // Scale stroke\n\n    var strokeWidth = this._strokeWidth;\n\n    if (strokeWidth) {\n      // Scale is the hypothenus between the two vectors\n      // TODO: Use area calculation instead\n      var vx = m.xx + m.xy,\n          vy = m.yy + m.yx;\n      strokeWidth *= Math.sqrt(vx * vx + vy * vy) / Math.sqrt(2);\n    } // convert to multiplied precision space\n\n\n    originX *= precision;\n    originY *= precision;\n    left *= precision;\n    top *= precision;\n    width *= precision;\n    height *= precision; // Set box\n\n    var element = this.element;\n    element.coordorigin = originX + ',' + originY;\n    element.coordsize = width + ',' + height;\n    element.style.left = left + 'px';\n    element.style.top = top + 'px';\n    element.style.width = width;\n    element.style.height = height;\n    element.style.rotation = rotation.toFixed(8);\n    element.style.flip = flip < 0 ? 'x' : ''; // Set transform\n\n    var skew = this.skewElement;\n    skew.matrix = [transform.xx.toFixed(4), transform.xy.toFixed(4), transform.yx.toFixed(4), transform.yy.toFixed(4), 0, 0];\n    skew.origin = transformOriginX + ',' + transformOriginY; // Set stroke\n\n    this.strokeElement.weight = strokeWidth + 'px';\n  },\n\n  /* styles */\n  _createGradient: function _createGradient(style, stops) {\n    var fill = this.fillElement; // Temporarily eject the fill from the DOM\n\n    this.element.removeChild(fill);\n    fill.type = style;\n    fill.method = 'none';\n    fill.rotate = true;\n    var colors = [],\n        color1,\n        color2;\n\n    var addColor = function addColor(offset, color) {\n      color = Color.detach(color);\n      if (color1 == null) color1 = color2 = color;else color2 = color;\n      colors.push(offset + ' ' + color[0]);\n    }; // Enumerate stops, assumes offsets are enumerated in order\n\n\n    if ('length' in stops) for (var i = 0, l = stops.length - 1; i <= l; i++) {\n      addColor(i / l, stops[i]);\n    } else for (var offset in stops) {\n      addColor(offset, stops[offset]);\n    }\n    fill.color = color1[0];\n    fill.color2 = color2[0]; //if (fill.colors) fill.colors.value = colors; else\n\n    fill.colors = colors; // Opacity order gets flipped when color stops are specified\n\n    fill.opacity = color2[1];\n    fill['ao:opacity2'] = color1[1];\n    fill.on = true;\n    this.element.appendChild(fill);\n    return fill;\n  },\n  _setColor: function _setColor(type, color) {\n    var element = type == 'fill' ? this.fillElement : this.strokeElement;\n\n    if (color == null) {\n      element.on = false;\n    } else {\n      color = Color.detach(color);\n      element.color = color[0];\n      element.opacity = color[1];\n      element.on = true;\n    }\n  },\n  fill: function fill(color) {\n    if (arguments.length > 1) {\n      this.fillLinear(arguments);\n    } else {\n      this._boxCoords = defaultBox;\n      var fill = this.fillElement;\n      fill.type = 'solid';\n      fill.color2 = '';\n      fill['ao:opacity2'] = '';\n      if (fill.colors) fill.colors.value = '';\n\n      this._setColor('fill', color);\n    }\n\n    return this;\n  },\n  fillRadial: function fillRadial(stops, focusX, focusY, radiusX, radiusY, centerX, centerY) {\n    var fill = this._createGradient('gradientradial', stops);\n\n    if (focusX == null) focusX = this.left + this.width * 0.5;\n    if (focusY == null) focusY = this.top + this.height * 0.5;\n    if (radiusY == null) radiusY = radiusX || this.height * 0.5;\n    if (radiusX == null) radiusX = this.width * 0.5;\n    if (centerX == null) centerX = focusX;\n    if (centerY == null) centerY = focusY;\n    centerX += centerX - focusX;\n    centerY += centerY - focusY;\n    var box = this._boxCoords = {\n      left: centerX - radiusX * 2,\n      top: centerY - radiusY * 2,\n      width: radiusX * 4,\n      height: radiusY * 4\n    };\n    focusX -= box.left;\n    focusY -= box.top;\n    focusX /= box.width;\n    focusY /= box.height;\n    fill.focussize = '0 0';\n    fill.focusposition = focusX + ',' + focusY;\n    fill.focus = '50%';\n\n    this._transform();\n\n    return this;\n  },\n  fillLinear: function fillLinear(stops, x1, y1, x2, y2) {\n    var fill = this._createGradient('gradient', stops);\n\n    fill.focus = '100%';\n\n    if (arguments.length == 5) {\n      var w = Math.abs(x2 - x1),\n          h = Math.abs(y2 - y1);\n      this._boxCoords = {\n        left: Math.min(x1, x2),\n        top: Math.min(y1, y2),\n        width: w < 1 ? h : w,\n        height: h < 1 ? w : h\n      };\n      fill.angle = (360 + Math.atan2((x2 - x1) / h, (y2 - y1) / w) * 180 / Math.PI) % 360;\n    } else {\n      this._boxCoords = null;\n      fill.angle = x1 == null ? 0 : (90 + x1) % 360;\n    }\n\n    this._transform();\n\n    return this;\n  },\n  fillImage: function fillImage(url, width, height, left, top, color1, color2) {\n    var fill = this.fillElement;\n\n    if (color1 != null) {\n      color1 = Color.detach(color1);\n      if (color2 != null) color2 = Color.detach(color2);\n      fill.type = 'pattern';\n      fill.color = color1[0];\n      fill.color2 = color2 == null ? color1[0] : color2[0];\n      fill.opacity = color2 == null ? 0 : color2[1];\n      fill['ao:opacity2'] = color1[1];\n    } else {\n      fill.type = 'tile';\n      fill.color = '';\n      fill.color2 = '';\n      fill.opacity = 1;\n      fill['ao:opacity2'] = 1;\n    }\n\n    if (fill.colors) fill.colors.value = '';\n    fill.rotate = true;\n    fill.src = url;\n    fill.size = '1,1';\n    fill.position = '0,0';\n    fill.origin = '0,0';\n    fill.aspect = 'ignore'; // ignore, atleast, atmost\n\n    fill.on = true;\n    if (!left) left = 0;\n    if (!top) top = 0;\n    this._boxCoords = width ? {\n      left: left + 0.5,\n      top: top + 0.5,\n      width: width,\n      height: height\n    } : null;\n\n    this._transform();\n\n    return this;\n  },\n\n  /* stroke */\n  stroke: function stroke(color, width, cap, join) {\n    var stroke = this.strokeElement;\n    this._strokeWidth = width != null ? width : 1;\n    stroke.weight = width != null ? width + 'px' : 1;\n    stroke.endcap = cap != null ? cap == 'butt' ? 'flat' : cap : 'round';\n    stroke.joinstyle = join != null ? join : 'round';\n\n    this._setColor('stroke', color);\n\n    return this;\n  }\n});\n;\n\n(function () {\n  var reactHotLoader = (typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal : require('react-hot-loader')).default;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(precision, \"precision\", \"D:\\\\projects\\\\gooddollar\\\\react-native-app\\\\GoodIdentity\\\\node_modules\\\\art\\\\modes\\\\vml\\\\base.js\");\n  reactHotLoader.register(defaultBox, \"defaultBox\", \"D:\\\\projects\\\\gooddollar\\\\react-native-app\\\\GoodIdentity\\\\node_modules\\\\art\\\\modes\\\\vml\\\\base.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = (typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal : require('react-hot-loader')).leaveModule;\n  leaveModule && leaveModule(module);\n})();","map":null,"metadata":{},"sourceType":"script"}